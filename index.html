<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Voice Blast</title>
<style>
  :root { --pad: 14px; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; max-width: 640px; margin: 24px auto; padding: 0 var(--pad); }
  h2 { margin: 12px 0; }
  .card { border: 1px solid #e5e7eb; border-radius: 16px; padding: 16px; box-shadow: 0 1px 4px rgba(0,0,0,.06); }
  .row { display: flex; gap: 10px; margin: 12px 0; }
  .row > * { flex: 1; }
  label { font-size: 13px; color: #374151; display:block; margin-bottom: 6px; }
  input, select, textarea { width: 100%; padding: 11px 12px; border: 1px solid #d1d5db; border-radius: 12px; }
  textarea { min-height: 120px; resize: vertical; }
  button { padding: 12px 16px; border: 0; border-radius: 12px; cursor: pointer; font-weight: 600; }
  .primary { background: #2563eb; color: white; }
  .ghost { background: #f3f4f6; }
  .danger { background: #ef4444; color: white; }
  .muted { color: #6b7280; font-size: 13px; }
  .status { margin-top: 8px; min-height: 24px; }
  .footer { margin-top: 18px; font-size: 12px; color: #6b7280; }
  .badge { display:inline-block; padding:2px 8px; border-radius:999px; background:#eef2ff; color:#3730a3; font-size:11px; margin-left:8px; }
</style>
</head>
<body>
  <h2>Speak &amp; Send</h2>
  <p class="muted">Tap Record, say your message, Stop, then Send. Your recording is sent securely to Make.</p>

  <div class="card">
    <div class="row">
      <div>
        <label for="audience">Audience</label>
        <select id="audience">
          <option value="all">All Staff</option>
          <option value="managers">Managers</option>
          <option value="frontdesk">Front Office</option>
          <option value="backoffice">Back Office</option>
        </select>
      </div>
      <div>
        <label for="subject">Subject (optional)</label>
        <input id="subject" placeholder="E.g., Quick update for today" />
      </div>
    </div>

    <!-- NEW: Your name for signature -->
    <div class="row">
      <div>
        <label for="sender">Your name (for signature)</label>
        <input id="sender" placeholder="e.g., Jake Mancuso" />
        <div class="muted" style="margin-top:6px;">If provided, your message will end with “— Your Name”.</div>
      </div>
    </div>

    <div class="row">
      <button id="recBtn" class="danger">● Record</button>
      <button id="stopBtn" class="ghost" disabled>■ Stop</button>
      <button id="sendBtn" class="primary" disabled>✉ Send</button>
      <button id="resetBtn" class="ghost">↺ Reset</button>
    </div>

    <!-- Live transcript toggle + preview -->
    <div class="row" style="align-items:center">
      <div style="flex:0 0 160px">
        <label>
          <input type="checkbox" id="livePreviewToggle" />
          Live text preview
        </label>
        <div id="srSupport" class="muted" style="margin-top:4px;"></div>
      </div>
      <div>
        <label for="preview">Text preview (beta) <span class="badge">Web Speech</span></label>
        <textarea id="preview" placeholder="Your words will appear here while recording…" readonly></textarea>
      </div>
    </div>

    <div class="status" id="status"></div>
  </div>

  <div class="footer">
    Tip: If this page says microphone permission is blocked, allow mic access in your browser settings for this site.
  </div>

<script>
const WEBHOOK = "https://hook.us1.make.com/kn9o6wkh911yoxe2v927qmity6boq16b";
const SECRET = "Secret123";

let mediaRecorder, chunks = [], lastBlob = null, lastMime = null;

// --- Speech Recognition (for live text preview) ---
const SR = window.SpeechRecognition || window.webkitSpeechRecognition || null;
let recognition = null;
let interimTxt = "", finalTxt = "";
const previewEl = document.getElementById('preview');
const liveToggle = document.getElementById('livePreviewToggle');
const srSupportEl = document.getElementById('srSupport');

if (SR) {
  srSupportEl.textContent = "Supported in this browser.";
} else {
  srSupportEl.textContent = "Not supported in this browser. Try Chrome on desktop.";
  liveToggle.disabled = true;
}

function startRecognition() {
  if (!SR || !liveToggle.checked) return;
  interimTxt = ""; finalTxt = "";
  recognition = new SR();
  recognition.lang = 'en-US';
  recognition.continuous = true;
  recognition.interimResults = true;

  recognition.onresult = (event) => {
    interimTxt = "";
    for (let i = event.resultIndex; i < event.results.length; i++) {
      const res = event.results[i];
      if (res.isFinal) {
        finalTxt += res[0].transcript + " ";
      } else {
        interimTxt += res[0].transcript;
      }
    }
    previewEl.value = (finalTxt + (interimTxt ? " " + interimTxt : "")).trim();
  };

  recognition.onerror = (e) => {
    console.warn("SpeechRecognition error:", e.error);
  };

  recognition.onend = () => {
    if (mediaRecorder && mediaRecorder.state === "recording" && liveToggle.checked) {
      try { recognition.start(); } catch {}
    }
  };

  try { recognition.start(); } catch (e) { console.warn(e); }
}

function stopRecognition() {
  try { recognition && recognition.stop(); } catch {}
  recognition = null;
}

// --- Audio recording helpers ---
function extFor(mime) {
  if (!mime) return "webm";
  if (mime.includes("webm")) return "webm";
  if (mime.includes("ogg")) return "ogg";
  if (mime.includes("mp4")) return "m4a";
  if (mime.includes("aac")) return "aac";
  if (mime.includes("wav")) return "wav";
  return "webm";
}

const recBtn = document.getElementById('recBtn');
const stopBtn = document.getElementById('stopBtn');
const sendBtn = document.getElementById('sendBtn');
const statusEl = document.getElementById('status');

recBtn.onclick = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    chunks = [];
    try { mediaRecorder = new MediaRecorder(stream); }
    catch (e) { mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' }); }
    lastMime = mediaRecorder.mimeType || null;

    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.onstop = () => {
      const type = chunks[0]?.type || lastMime || 'audio/webm';
      lastBlob = new Blob(chunks, { type });
      sendBtn.disabled = false;
      const seconds = Math.max(1, Math.round((lastBlob.size / 32000)));
      statusEl.textContent = `Recorded ~${seconds}s · ${(lastBlob.size/1024).toFixed(1)} KB (${type})`;
    };

    mediaRecorder.start();
    recBtn.disabled = true; stopBtn.disabled = false; sendBtn.disabled = true;
    statusEl.textContent = "Recording…";

    startRecognition();
  } catch (e) {
    console.error(e);
    alert('Microphone permission is required. Please allow access.');
  }
};

stopBtn.onclick = () => {
  mediaRecorder?.stop();
  recBtn.disabled = false; stopBtn.disabled = true;
  statusEl.textContent = "Stopped. Ready to send.";
  stopRecognition();
};

sendBtn.onclick = async () => {
  if (!lastBlob) return;
  statusEl.textContent = "Uploading…";
  const audience = document.getElementById('audience').value;
  const subject = document.getElementById('subject').value;
  const sender = (document.getElementById('sender').value || "").trim();
  const filename = `note.${extFor(lastBlob.type)}`;

  // Build transcript and append signature if provided
  let transcript = (previewEl.value || "").trim();
  if (sender) {
    transcript = transcript ? `${transcript}\n\n— ${sender}` : `— ${sender}`;
  }

  const fd = new FormData();
  fd.append('audio', lastBlob, filename);
  fd.append('audience', audience);
  fd.append('subject', subject);
  fd.append('secret', SECRET);
  fd.append('sender', sender);        // NEW: raw sender field
  fd.append('transcript', transcript); // transcript with optional signature

  try {
    const res = await fetch(WEBHOOK, { method: 'POST', body: fd });
    statusEl.textContent = res.ok ? "Sent to Make ✅" : "Sent (check Make) ✅";
  } catch (e) {
    statusEl.textContent = "Failed to send ❌ (see console)";
    console.error(e);
  }
};
  const resetBtn = document.getElementById('resetBtn');

resetBtn.onclick = () => {
  // Stop any recording or speech recognition
  try { mediaRecorder?.stop(); } catch {}
  stopRecognition();

  // Clear state
  lastBlob = null; chunks = []; lastMime = null;
  previewEl.value = "";
  document.getElementById('subject').value = "";
  document.getElementById('sender').value = "";
  statusEl.textContent = "";

  // Reset button states
  recBtn.disabled = false;
  stopBtn.disabled = true;
  sendBtn.disabled = true;
};

// Optional: restart SR when toggle changes
liveToggle.addEventListener('change', () => {
  if (!liveToggle.checked) {
    stopRecognition();
  } else if (mediaRecorder && mediaRecorder.state === "recording") {
    startRecognition();
  }
});
</script>
</body>
</html>
